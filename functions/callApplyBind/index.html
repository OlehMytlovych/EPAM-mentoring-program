<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>callApplyBind</title>
  
  <script src="./js/delayingDecorator.js"></script>
  <script src="./js/debounceDecorator.js"></script>
  <script src="./js/throttleDecorator.js"></script>

  <style>
    body {
      background-color:lightcyan;
      margin: 10px;
    }
    .task {
      background-color:lightgreen;
      padding: 20px;
      margin-bottom: 10px;
    }
    p {
      font-size: larger;
    }
    pre {
      background-color: white;
      display: inline-block;
      font-size: 14px;
      padding: 15px;
    }
  </style>
</head>
<body>
  <div class="task">
    <h2>1. delayingDecorator.js</h2>
    <p class="instructions">
      Create a decorator delay(f, ms) that delays each call of f by ms milliseconds.
    </p>
    <p class="instructions">
      In other words, delay(f, ms) returns a "delayed by ms" variant of f.
    </p>

    <pre>
      <code>
        function f(x) {
          alert(x);
        }
        
        // create wrappers
        let f1000 = delay(f, 1000);
        let f1500 = delay(f, 1500);
        
        f1000("test"); // shows "test" after 1000ms
        f1500("test"); // shows "test" after 1500ms
      </code>
    </pre>

    <p class="instructions">
      In the code above, f is a function of a single argument, but your solution should pass all arguments and the context this.
    </p>
  </div>

  <div class="task">
    <h2>2. debounceDecorator.js</h2>
    <p class="instructions">
      The result of debounce(f, ms) decorator should be a wrapper that passes the call to f at maximum once per ms milliseconds.
    </p>
    <p class="instructions">
      In other words, when we call a “debounced” function, it guarantees that all future calls to the function made less than ms milliseconds after the previous call will be ignored.
    </p> 

    <pre>
      <code>
        let f = debounce(alert, 1000);

        f(1); // runs immediately
        f(2); // ignored

        setTimeout( () => f(3), 100); // ignored ( only 100 ms passed )
        setTimeout( () => f(4), 1100); // runs
        setTimeout( () => f(5), 1500); // ignored (less than 1000 ms from the last run)
      </code>
    </pre>
  </div>

  <div class="task">
    <h2>3. throttleDecorator.js</h2>
    <p class="instructions">
      Create a “throttling” decorator throttle(f, ms) – that returns a wrapper, passing the call to f at maximum once per ms milliseconds. Those calls that fall into the “cooldown” period, are ignored.
    </p>
    <p class="instructions">
      The difference with debounce – if an ignored call is the last during the cooldown, then it executes at the end of the delay.
    </p> 
    <p class="instructions">
      Arguments and the context this passed to f1000 should be passed to the original f.
    </p>
    <pre>
      <code>
        function f(a) {
          console.log(a);
        }
        
        // f1000 passes calls to f at maximum once per 1000 ms
        let f1000 = throttle(f, 1000);
        
        f1000(1); // shows 1
        f1000(2); // (throttling, 1000ms not out yet)
        f1000(3); // (throttling, 1000ms not out yet)
        
        // when 1000 ms time out...
        // ...outputs 3, intermediate value 2 was ignored
      </code>
    </pre>
  </div>
</body>
</html>